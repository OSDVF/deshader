// Copyright (C) 2024  Ond≈ôej Sabela
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

const std = @import("std");
const builtin = @import("builtin");
const options = @import("options");
const gl = @import("gl");
const common = @import("common");
const log = common.log;

const loaders = @import("loaders.zig");
const APIs = @import("loaders.zig").APIs;

const String = []const u8;

//
// Graphics API interception with trampoline generators
//
// TODO: can use ELF filters https://github.com/aritger/libgl-elf-tricks-demo on Linux or https://github.com/magnusstubman/dll-exports  #pragma comment(linker, "/export:func=target_module.func,@100") on Windows to avoid trampolines
pub const TransitiveSymbols = struct {
    const transitive_procs = @import("transitive_exports");

    fn createCBackendTrampoline(comptime target: *?*const anyopaque) type {
        // Trampoline generator
        return struct { // Captures `target`
            fn intercepted() callconv(.Naked) noreturn { // Naked trampoline preserves caller arguments
                @setRuntimeSafety(false);
                // This is a workaround to support C backend with many different compilers
                // Because they can use any register for storing [target]
                // RBX and RCX shohuld be callee-saved registers
                asm volatile ("push %%rbx");
                asm volatile ("push %%rcx");
                asm volatile ("mov %[target], %%rax"
                    :
                    : [target] "r" (target), // "m" is not supported because C compiler sees default value of target as null
                );
                asm volatile ("mov (%%rax), %%rax"); //dereference target
                asm volatile ("pop %%rcx");
                asm volatile ("pop %%rbx");
                asm volatile ("jmp *%%rax");
            }
        };
    }
    fn createTrampoline(comptime target: String) type {
        // Trampoline generator
        return struct { // Captures `target`
            fn intercepted() callconv(.Naked) noreturn { // Naked trampoline preserves caller arguments
                @setRuntimeSafety(false);
                switch (builtin.target.cpu.arch) {
                    .x86 => asm volatile ("jmp *%[target]"
                        :
                        : [target] "{eax}" (@field(transitive_procs, target)),
                        : "eax"
                    ),
                    .x86_64 => asm volatile ("jmp *%[target]" //Zig compiler respects the rax constraint so we dont need to save other registers
                        :
                        : [target] "{rax}" (@field(transitive_procs, target)),
                        : "rax"
                    ),
                    // TODO not tested anything other than x86
                    // Just generated by copilot
                    .arm, .armeb, .aarch64_32 => asm volatile ("b %[target]"
                        :
                        : [target] "{r0}" (@field(transitive_procs, target)),
                        : "r0"
                    ),
                    .aarch64, .aarch64_be => asm volatile ("b %[target]"
                        :
                        : [target] "{x0}" (@field(transitive_procs, target)),
                        : "x0"
                    ),
                    // TODO other archs
                    else => @compileError("Unsupported architecture " ++ @typeName(builtin.target.cpu.arch) ++ " for trampoline generation"),
                }
            }
        };
    }
    // Fill the mappings
    pub fn loadOriginal() !void {
        comptime var count: usize = 0;
        comptime var names: []String = undefined;

        // Export all known GL and VK functions
        comptime {
            //
            // Transitively export all GL, VK and system-specific (GLX, EGL) functions
            //
            // First pass to count the number of functions to export
            const recursive_procs_decls = @typeInfo(transitive_procs).Struct.decls;
            {
                @setEvalBranchQuota(150000); // Really a lot of functions to export
                var i = 0;
                eachRecursiveProc: for (recursive_procs_decls) |decl| {
                    const symbol_name = decl.name;
                    for (loaders.all_exported_names) |exported| {
                        if (exported != null and std.mem.eql(u8, exported.?, symbol_name)) {
                            continue :eachRecursiveProc;
                        }
                    }
                    const symbol = if (options.ofmt != .Default and builtin.target.cpu.arch == .x86_64) //
                        createCBackendTrampoline(&@field(transitive_procs, symbol_name)).intercepted
                    else
                        createTrampoline(symbol_name).intercepted;
                    @export(symbol, .{ .name = symbol_name });
                    defer i += 1;
                }

                count = i;
            }

            //
            // A second pass to fill `names` and `mapping` array
            //
            {
                var new_names: [count]String = undefined;
                names = &new_names;

                var i = 0;
                eachRecursiveProc: for (recursive_procs_decls) |decl| {
                    const symbol_name = decl.name;
                    for (loaders.all_exported_names) |exported| {
                        if (exported != null and std.mem.eql(u8, exported.?, symbol_name)) {
                            continue :eachRecursiveProc;
                        }
                    }
                    defer i += 1;
                    names[i] = symbol_name;
                }
            }
        } // end comptime

        //
        // Runtime loadOriginal() code
        //

        // Fill the mappings array
        inline for (names) |symbol_name| {
            const prefix = symbol_name[0];
            var lib = switch (prefix) { // TODO specify different mapping discriminator than a prefix
                'g' => if (builtin.os.tag == .windows) APIs.gl.wgl.lib else APIs.gl.glX.lib,
                'v' => APIs.vk.lib.?,
                'e' => APIs.gl.egl.lib,
                'w' => APIs.gl.wgl.lib,
                else => @panic(try std.fmt.allocPrint(common.allocator, "Unknown GL or VK function prefix: {c}", .{prefix})),
            };
            const with_null = try common.allocator.dupeZ(u8, symbol_name);
            defer common.allocator.free(with_null);
            if (lib != null) {
                const symbol_target = lib.?.lookup(gl.PROC, with_null);
                if (symbol_target != null) {
                    @field(transitive_procs, symbol_name) = symbol_target.?;
                } else {
                    log.err("Failed to find symbol {s}", .{symbol_name});
                }
            }
        }
    }
};
